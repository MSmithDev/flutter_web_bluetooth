part of flutter_web_bluetooth;

///
/// A Bluetooth low energy (web) device. This represents a device that (may)
/// be connected to the browser using BLE.
///
/// You can get a [BluetoothDevice] by calling
/// [FlutterWebBluetooth.requestDevice].
///
class BluetoothDevice {
  ///
  /// A constructor for a new device.
  ///
  /// **This should only be done by the library or if you're testing.**
  ///
  /// To get an instance use [FlutterWebBluetooth.requestDevice].
  ///
  BluetoothDevice(this._bluetoothDevice);

  final WebBluetoothDevice _bluetoothDevice;

  ///
  /// Get the id of the device.
  ///
  /// This id is randomly generated by the browser. A new id is generated for
  /// each session unless a flag is used to remember previously connected
  /// devices.
  ///
  /// The browser may decide how this is generated. On Chrome this is 128
  /// randomly generated bits that are encoded in base 64.
  ///
  String get id => _bluetoothDevice.id;

  ///
  /// A human readable name of the device.
  ///
  /// This name comes straight from the device itself.
  ///
  /// You could also use the [BluetoothDefaultCharacteristicUUIDS.DEVICE_NAME]
  /// to get the same value (if it exists).
  ///
  /// And maybe even rename it if it allows for writing.
  ///
  String? get name => _bluetoothDevice.name;

  WebBehaviorSubject<bool>? _connectionSubject;

  ///
  /// A stream that gives the current connection state.
  ///
  /// This will be `true` if the device is currently connected, it will also
  /// update if for whatever reason the connection is broken.
  ///
  Stream<bool> get connected {
    _startConnectedStream();
    return _connectionSubject!.stream;
  }

  void _startConnectedStream() {
    if (_connectionSubject != null) {
      return;
    }

    // ignore: deprecated_member_use_from_same_package
    _connectionSubject = WebBehaviorSubject.seeded(gatt?.connected == true);

    _bluetoothDevice.addEventListener('gattserverdisconnected',
        (dynamic event) {
      _connectionSubject?.add(false);
      if (_servicesSubject.hasValue) {
        _servicesSubject.add([]);
      }
    });
  }

  ///
  /// Check to see if the device currently has a GATT connection.
  ///
  /// Some devices may allow you to find them, but they are on a blocklist
  /// restricting the ability to communicate with its GATT service.
  ///
  /// ignore: deprecated_member_use_from_same_package
  bool get hasGATT => gatt != null;

  ///
  /// Disconnect from the device.
  ///
  /// See [hasGATT].
  ///
  void disconnect() {
    // ignore: deprecated_member_use_from_same_package
    gatt?.disconnect();
  }

  ///
  /// Connect to the device's GATT server.
  ///
  /// The [connect] call may timeout after [timeout] if set to `null` then it
  /// will never timeout. Call [disconnect] if you want to cancel it in that
  /// case.
  ///
  /// - May throw [TypeError] if there is no gatt. Always check [hasGATT] before
  /// calling this method.
  ///
  /// - May throw [NetworkError] if no connection could be established.
  ///
  /// - May throw [StateError] if the connection was aborted. TODO: use a better error.
  ///
  Future<void> connect({Duration? timeout = const Duration(seconds: 5)}) async {
    // ignore: deprecated_member_use_from_same_package
    final gatt = this.gatt!;
    _startConnectedStream();
    // No timeout.
    try {
      if (timeout == null) {
        await gatt.connect();
      } else {
        await gatt.connect().timeout(timeout);
      }
    } catch (e) {
      if (e is TimeoutException) {
        disconnect();
        rethrow;
      }
      final error = e.toString().trim();
      if (error.startsWith('NetworkError')) {
        throw NetworkError.withDeviceId(id);
      } else if (error.startsWith('AbortError')) {
        throw StateError('Connection attempt was aborted!');
      }
      rethrow;
    }

    _connectionSubject?.add(true);
  }

  final WebBehaviorSubject<List<BluetoothService>> _servicesSubject =
      WebBehaviorSubject.seeded([]);

  ///
  /// A [Stream] with a list of all the [BluetoothService] that have been discovered on
  /// this device.
  ///
  /// Getting this [Stream] while [connected] is `true` will also result in a
  /// call to [discoverServices]. If this hasn't happened yet.
  Stream<List<BluetoothService>> get services async* {
    while (_connectionSubject == null ||
        _connectionSubject?.value == false ||
        _connectionSubject?.hasValue == false) {
      yield [];
    }
    if (_servicesSubject.value?.isEmpty == true) {
      yield await discoverServices();
    }
    yield* _servicesSubject.stream;
  }

  ///
  /// Discover the primary services on this device.
  ///
  /// Will return a list of [BluetoothService].
  ///
  /// Only services defined in the [RequestOptionsBuilder] from when
  /// [FlutterWebBluetooth.requestDevice] was called are available.
  ///
  /// Will also update the [services] stream with the data returned form this
  /// method.
  ///
  /// - May throw [StateError] if the device is not connected.
  ///
  Future<List<BluetoothService>> discoverServices() async {
    // ignore: deprecated_member_use_from_same_package
    final gatt = this.gatt;
    if (gatt == null || !gatt.connected) {
      throw StateError(
          'Cannot discover services if the device is not connected.');
    }

    try {
      final services = await gatt.getPrimaryServices();
      final convertedServices =
          services.map((e) => BluetoothService(e)).toList();
      _servicesSubject.add(convertedServices);
      return convertedServices;
    } catch (e) {
      final error = e.toString().trim();
      if (error.startsWith('SecurityError')) {
        throw SecurityError("getPrimaryServices", error);
      } else if (error.startsWith('NetworkError')) {
        throw StateError(
            'Cannot discover services if the device is not connected.');
      } else if (error.startsWith('InvalidStateError')) {
        throw StateError('GATT is null');
      } else if (error.startsWith('NotFoundError')) {
        _servicesSubject.add([]);
        return [];
      }
      rethrow;
    }
  }

  /// Get the underlying native (web) gatt service.
  @visibleForTesting
  @Deprecated('This is here for debugging and will be removed once web '
      'bluetooth is actually released. '
      '(It will still exist as visible for testing)')
  NativeBluetoothRemoteGATTServer? get gatt => _bluetoothDevice.gatt;

  ///
  /// Get the underlying native (web) bluetooth device.
  ///
  @Deprecated('This is here for debugging and will be removed once web '
      'bluetooth is actually released.')
  WebBluetoothDevice get nativeDevice => _bluetoothDevice;

  ///
  /// Check to see if two device have the same id.
  ///
  @override
  bool operator ==(Object other) {
    if (other is! BluetoothDevice) {
      return false;
    }
    return id == other.id;
  }

  @override
  int get hashCode => id.hashCode;
}
